<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-14">

<title>Random variables &amp; information – john myers, ph.d.</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/fav.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-e70e373d709ee9d216e9a1aea6657d26.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ccc6b90b4d1ed2bb7ba759a873171846.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VWK3RHBGT2"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-VWK3RHBGT2', { 'anonymize_ip': true});
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&amp;family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&amp;family=Nunito:ital,wght@0,200..1000;1,200..1000&amp;display=swap" rel="stylesheet">
<meta name="quarto:status" content="draft">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../writings.html"> 
<span class="menu-text">writings</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teaching" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">teaching</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-teaching">    
        <li>
    <a class="dropdown-item" href="../../teaching/calculus-ii-fa-25.html">
 <span class="dropdown-text">mat220 calculus II, fall 2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../teaching/analysis-fa-25.html">
 <span class="dropdown-text">mat347 analysis, fall 2025</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="https://www.johnmyers-phd.com/book" target="_blank"> 
<span class="menu-text">probabilistic machine learning</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jmyers7/" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/john-myers-phd" target="_blank"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:jmmyers25@gmail.com"> <i class="bi bi-envelope-open-fill" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#random-variables-as-information-carriers" id="toc-random-variables-as-information-carriers" class="nav-link" data-scroll-target="#random-variables-as-information-carriers">Random variables as information carriers</a></li>
  <li><a href="#hilbert-spaces-of-random-variables" id="toc-hilbert-spaces-of-random-variables" class="nav-link" data-scroll-target="#hilbert-spaces-of-random-variables">Hilbert spaces of random variables</a></li>
  <li><a href="#conditional-expectations-as-projections" id="toc-conditional-expectations-as-projections" class="nav-link" data-scroll-target="#conditional-expectations-as-projections">Conditional expectations as projections</a></li>
  <li><a href="#coin-flips-revisited" id="toc-coin-flips-revisited" class="nav-link" data-scroll-target="#coin-flips-revisited">Coin flips revisited</a></li>
  <li><a href="#brief-note-on-sufficient-statistics" id="toc-brief-note-on-sufficient-statistics" class="nav-link" data-scroll-target="#brief-note-on-sufficient-statistics">Brief note on sufficient statistics</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#bibliography" id="toc-bibliography" class="nav-link" data-scroll-target="#bibliography">Bibliography</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Random variables &amp; information</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Information theory</div>
    <div class="quarto-category">Probability theory</div>
    <div class="quarto-category">Measure theory</div>
    <div class="quarto-category">Sigma-algebras</div>
    <div class="quarto-category">Conditional expectations</div>
    <div class="quarto-category">Hilbert spaces</div>
    <div class="quarto-category">Linear algebra</div>
    <div class="quarto-category">R</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 14, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In our <a href="../../posts/info-2/index.html">previous post</a>, we explored how algebras of sets represent an observer’s information about an uncertain outcome. We saw that algebras correspond to partitions of the sample space, and we quantified the information content of these structures using entropy, conditional entropy, and mutual information. But algebras alone don’t capture all the richness of probabilistic reasoning. When we want to make predictions, compute averages, or measure quantities of interest, we need <em>random variables</em>.</p>
<p>A random variable is fundamentally a function <span class="math inline">\(X: \Omega \to \mathbb{R}\)</span> that assigns a numerical value to each outcome. However, from an information-theoretic perspective, a random variable serves a dual role: it both <em>encodes information</em> (through the algebra <span class="math inline">\(\sigma(X)\)</span> it generates) and <em>represents measurable quantities</em> (as an element of the function space <span class="math inline">\(L^2(\Omega)\)</span>). This post develops both perspectives and shows how they connect.</p>
<p>We begin by showing how random variables generate algebras through their level sets, establishing a <strong>functional characterization</strong> of information containment: <span class="math inline">\(X\)</span> contains at least as much information as <span class="math inline">\(Y\)</span> if and only if <span class="math inline">\(X = f \circ Y\)</span> for some function <span class="math inline">\(f\)</span>. We then introduce the geometric structure of <span class="math inline">\(L^2(\Omega)\)</span>, where random variables are vectors and conditional expectation emerges as <strong>orthogonal projection</strong> onto subspaces determined by algebras. Throughout, we’ll revisit our coin-flip example, computing conditional expectations explicitly and visualizing how predictions improve as information refines.</p>
<p>These ideas form the foundation for modern probability theory. Conditional expectation provides the optimal predictor given partial information, martingales arise as processes where current values are the best forecasts of future values, and options pricing in mathematical finance reduces to computing conditional expectations under risk-neutral measures. By understanding random variables as both information carriers and geometric objects, we gain the tools to analyze learning, prediction, and decision-making under uncertainty.</p>
</section>
<section id="random-variables-as-information-carriers" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="random-variables-as-information-carriers">Random variables as information carriers</h2>
<p>We begin with the definition of these <em>level sets</em>:</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-rv-part" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1</strong></span> Let <span class="math inline">\(X:\Omega\to \mathbb{R}\)</span> be a real-valued function on a set <span class="math inline">\(\Omega\)</span>. For <span class="math inline">\(x\in X\)</span>, sets of the form</p>
<p><span class="math display">\[
X^{-1}(x) \overset{\text{def}}{=}\{ \omega \in \Omega : X(\omega)=x\}
\]</span></p>
<p>are called <em>level sets</em>.</p>
</div>
</div>
</div>
</div>
<p>As you may easily check, the nonempty level sets of a function <span class="math inline">\(X:\Omega \to \mathbb{R}\)</span> partition its domain (assumed to be finite), and through this partition the function <span class="math inline">\(X\)</span> generates an algebra of sets in <span class="math inline">\(\Omega\)</span> denoted <span class="math inline">\(\sigma(X)\)</span>. The level sets are the atoms of this algebra.</p>
<p>Thus, the function <span class="math inline">\(X\)</span> is a carrier of information. If <span class="math inline">\(\Omega\)</span> consists of the outcomes of an experiment, the information encoded in the algebra <span class="math inline">\(\sigma(X)\)</span> allows an observer to decide whether <span class="math inline">\(\omega \in X^{-1}(x)\)</span> for each <span class="math inline">\(x\in \mathbb{R}\)</span>, and thus the observer can determine the value <span class="math inline">\(X(\omega)\)</span>.</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="thm-rv-refine" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Random variables and refinements)</strong></span> Let <span class="math inline">\(\mathcal{F}\)</span> be an algebra of sets in a finite set <span class="math inline">\(\Omega\)</span>, and let <span class="math inline">\(X:\Omega \to \mathbb{R}\)</span> be a function.</p>
<ol type="1">
<li><p>The algebra <span class="math inline">\(\mathcal{F}\)</span> refines <span class="math inline">\(\sigma(X)\)</span> if and only if <span class="math inline">\(X\)</span> is constant on every atom in <span class="math inline">\(\mathcal{F}\)</span>.</p></li>
<li><p>The algebra <span class="math inline">\(\sigma(X)\)</span> refines <span class="math inline">\(\mathcal{F}\)</span> if and only if every atom in <span class="math inline">\(\mathcal{F}\)</span> is a union of level sets of <span class="math inline">\(X\)</span>.</p></li>
</ol>
</div>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Proof.
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The algebra <span class="math inline">\(\mathcal{F}\)</span> refines <span class="math inline">\(\sigma(X)\)</span> if and only if every nonempty level set is a union of atoms in <span class="math inline">\(\mathcal{F}\)</span>. This proves the result in the first statement. A symmetric argument using the same theorem proves the second statement.</p>
</div>
</div>
</div>
<p>It will be convenient to adopt some terminology from measure theory:</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-measurable" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2</strong></span> Let <span class="math inline">\(\mathcal{F}\)</span> be an algebra of sets in a finite set <span class="math inline">\(\Omega\)</span>. A function <span class="math inline">\(X:\Omega \to \mathbb{R}\)</span> will be called <em><span class="math inline">\(\mathcal{F}\)</span>-measurable</em> if <span class="math inline">\(\mathcal{F}\)</span> refines the algebra <span class="math inline">\(\sigma(X)\)</span>.</p>
</div>
</div>
</div>
</div>
<p>We have seen that every random variable <span class="math inline">\(X\)</span> generates an algebra <span class="math inline">\(\sigma(X)\)</span> through its level sets. When two random variables <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are related by <span class="math inline">\(\sigma(X) \subset \sigma(Y)\)</span>, we say that <span class="math inline">\(Y\)</span> <em>refines</em> <span class="math inline">\(X\)</span> or, equivalently, that <span class="math inline">\(Y\)</span> contains at least as much information as <span class="math inline">\(X\)</span>. But what does this mean concretely? The following theorem provides a functional characterization: <span class="math inline">\(\sigma(X) \subset \sigma(Y)\)</span> if and only if <span class="math inline">\(X\)</span> can be computed from <span class="math inline">\(Y\)</span> via a deterministic function. This makes the notion of “information containment” precise and operational.</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="thm-functional-rep" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 (Functional representation)</strong></span> Let <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> be two functions on a finite set <span class="math inline">\(\Omega\)</span>. The following statements are equivalent:</p>
<ol type="1">
<li>The algebra <span class="math inline">\(\sigma(Y)\)</span> refines <span class="math inline">\(\sigma(X)\)</span>, i.e., <span class="math inline">\(\sigma(X) \subset \sigma(Y)\)</span>.</li>
<li>There exists a function <span class="math inline">\(f:\mathbb{R}\to \mathbb{R}\)</span> such that <span class="math inline">\(X = f \circ Y\)</span>.</li>
</ol>
</div>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Proof.
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Suppose that <span class="math inline">\(\sigma(Y)\)</span> refines <span class="math inline">\(\sigma(X)\)</span> and write</p>
<p><span class="math display">\[
X = \sum_{i=1}^m x_i I_{A_i} \quad \text{and} \quad Y = \sum^n_{j=1} y_j I_{B_j}.
\]</span></p>
<p>Then every level set <span class="math inline">\(B_j = Y^{-1}(y_j)\)</span> is contained in a unique level set <span class="math inline">\(A_i = X^{-1}(x_i)\)</span>, and we may define a function</p>
<p><span class="math display">\[
h:\{y_1,\ldots,y_n\} \to \mathbb{R}
\]</span></p>
<p>by setting <span class="math inline">\(h(y_j) = x_i\)</span> if <span class="math inline">\(B_j \subset A_i\)</span>. Then, define</p>
<p><span class="math display">\[
\pi: \mathbb{R}\to \mathbb{R}, \quad \pi(y) = \sum_{j=1}^n \delta_{y_j}(y),
\]</span></p>
<p>where <span class="math inline">\(\delta_{y_j}\)</span> is a Dirac delta function. If we then set <span class="math inline">\(f = h \circ \pi\)</span> and choose <span class="math inline">\(\omega\)</span> in an arbitrary <span class="math inline">\(B_j\)</span>, we have</p>
<p><span class="math display">\[
f(Y(\omega)) = (h\circ \pi)(y_j) = h(y_j) = x_i = X(\omega).
\]</span></p>
<p>Since <span class="math inline">\(B_j\)</span> and <span class="math inline">\(\omega\)</span> were chosen arbitrarily, this proves that (1) implies (2).</p>
<p>To prove the converse, suppose that <span class="math inline">\(X = f \circ Y\)</span> for some function <span class="math inline">\(f:\mathbb{R}\to \mathbb{R}\)</span>. To prove that <span class="math inline">\(\sigma(Y)\)</span> refines <span class="math inline">\(\sigma(X)\)</span>, by <a href="#thm-rv-refine" class="quarto-xref">Theorem&nbsp;1</a> it will suffice to show that every level set of <span class="math inline">\(Y\)</span> is contained in a level set of <span class="math inline">\(X\)</span>. So, let <span class="math inline">\(y \in \mathbb{R}\)</span> and consider the level set <span class="math inline">\(B = Y^{-1}(y)\)</span>. If <span class="math inline">\(B\)</span> is nonempty, then for every <span class="math inline">\(\omega \in B\)</span>, we have <span class="math inline">\(X(\omega) = f(Y(\omega)) = f(y)\)</span>. Thus, <span class="math inline">\(B \subset X^{-1}(f(y))\)</span>, and the proof is complete.</p>
</div>
</div>
</div>
<p>This theorem provides a precise characterization of when one random variable “contains at least as much information” as another. The condition <span class="math inline">\(\sigma(X) \subset \sigma(Y)\)</span> means that knowing <span class="math inline">\(Y\)</span> allows you to determine <span class="math inline">\(X\)</span>, while the functional representation <span class="math inline">\(X = f \circ Y\)</span> makes this explicit: <span class="math inline">\(X\)</span> is literally computed from <span class="math inline">\(Y\)</span>. Conversely, if <span class="math inline">\(Y\)</span> cannot determine <span class="math inline">\(X\)</span>, then <span class="math inline">\(\sigma(X) \not\subset \sigma(Y)\)</span> and no such function <span class="math inline">\(f\)</span> exists.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>The theorem is actually true in much more generality thatn we have stated it here, but the proof is more involved. See, for example, Lemma 1.14 in <span class="citation" data-cites="Kallenberg2021">(<a href="#ref-Kallenberg2021" role="doc-biblioref">Kallenberg 2021</a>)</span> for a complete treatment.</p>
</div></div></section>
<section id="hilbert-spaces-of-random-variables" class="level2">
<h2 class="anchored" data-anchor-id="hilbert-spaces-of-random-variables">Hilbert spaces of random variables</h2>
<p>We’ve seen how random variables encode information through the algebras they generate. But random variables also have numerical values, which allows us to perform algebraic operations: we can add them, multiply them by scalars, and compute their expected values. This algebraic structure becomes particularly rich when we introduce an inner product, turning the space of random variables into a Hilbert space. This geometric perspective will prove essential for understanding conditional expectation, which emerges naturally as orthogonal projection onto subspaces determined by algebras.</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-L2" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3</strong></span> Let <span class="math inline">\((\Omega,\mathcal{F},P)\)</span> be a finite probability space. We write <span class="math inline">\(L^2(\Omega,\mathcal{F},P)\)</span> for the set of all <span class="math inline">\(\mathcal{F}\)</span>-measurable functions <span class="math inline">\(X:\Omega \to \mathbb{R}\)</span>. When the set <span class="math inline">\(\Omega\)</span> and the measure <span class="math inline">\(P\)</span> are understood from context, we will abbreviate <span class="math inline">\(L^2(\Omega,\mathcal{F},P)\)</span> as <span class="math inline">\(L^2(\mathcal{F})\)</span>.</p>
</div>
</div>
</div>
</div>
<p>The <span class="math inline">\(L^2\)</span> notation is borrowed from the case that <span class="math inline">\(\Omega\)</span> is infinite and equipped with a probability measure <span class="math inline">\(P\)</span> on a <span class="math inline">\(\sigma\)</span>-algebra <span class="math inline">\(\mathcal{F}\)</span>. In that case, <span class="math inline">\(L^2(\Omega,\mathcal{F},P)\)</span> consists of all (equivalence classes of) <span class="math inline">\(\mathcal{F}\)</span>-measurable functions <span class="math inline">\(X:\Omega \to \mathbb{R}\)</span> such that <span class="math inline">\(E(X^2) &lt; \infty\)</span>. In our finite setting, this condition on the expectation of <span class="math inline">\(X^2\)</span> is automatically satisfied.</p>
<p>The probability measure <span class="math inline">\(P\)</span> does not factor into the definition of <span class="math inline">\(L^2(\mathcal{F})\)</span>, but it does define an inner product on this space:</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="thm-inner-prod" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (<span class="math inline">\(L^2(\mathcal{F})\)</span> is a Hilbert space)</strong></span> Let <span class="math inline">\((\Omega,\mathcal{F},P)\)</span> be a finite probability space. The map <span class="math display">\[
\langle -, - \rangle : L^2(\mathcal{F}) \times L^2(\mathcal{F}) \to \mathbb{R}, \quad \langle X, Y \rangle = E(XY)
\]</span> defines an inner product on <span class="math inline">\(L^2(\mathcal{F})\)</span>.</p>
</div>
</div>
</div>
</div>
<p>Using the Lebesgue integral notation, the inner product can be written as</p>
<p><span class="math display">\[
\langle X, Y \rangle = \int_\Omega X(\omega) Y(\omega) \ P(d\omega).
\]</span></p>
<p>Of course, if <span class="math inline">\(p_{X,Y}\)</span> is the joint probability mass function of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, then we may also write the inner product as a discrete sum:</p>
<p><span class="math display">\[
\langle X, Y \rangle = \sum_{x,y\in \mathbb{R}} x y \,  p_{X,Y}(x,y).
\]</span></p>
<p>The inner product induces a norm</p>
<p><span class="math display">\[
\|X\| = \sqrt{\langle X, X \rangle} = \sqrt{E(X^2)},
\]</span></p>
<p>which measures the “magnitude” of a random variable. This is precisely the so-called <em><span class="math inline">\(L^2\)</span> norm</em>, and the corresponding metric <span class="math inline">\(d(X, Y) = \|X - Y\|\)</span> measures the mean-squared distance between random variables. In statistics, this is the root mean squared error (RMSE) between <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>.</p>
<p>When algebras are nested, their corresponding <span class="math inline">\(L^2\)</span> Hilbert spaces are nested as well:</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="thm-nested-subspaces" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4</strong></span> Let <span class="math inline">\((\Omega, \mathcal{F}, P)\)</span> be a finite probability space. If <span class="math inline">\(\mathcal{G} \subset \mathcal{H}\)</span> are two sub-algebras of <span class="math inline">\(\mathcal{F}\)</span>, then <span class="math display">\[
L^2(\mathcal{G}) \subset L^2(\mathcal{H}) \subset L^2(\mathcal{F}).
\]</span></p>
<p>Moreover, these subset inclusions are ones of vector subspaces.</p>
</div>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Proof.
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>If <span class="math inline">\(X \in L^2(\mathcal{G})\)</span>, then <span class="math inline">\(X\)</span> is <span class="math inline">\(\mathcal{G}\)</span>-measurable. Since <span class="math inline">\(\mathcal{G} \subset \mathcal{H}\)</span>, every set in <span class="math inline">\(\mathcal{G}\)</span> is also in <span class="math inline">\(\mathcal{H}\)</span>, so <span class="math inline">\(X\)</span> is <span class="math inline">\(\mathcal{H}\)</span>-measurable, hence <span class="math inline">\(X \in L^2(\mathcal{H})\)</span>. The second inclusion follows identically.</p>
</div>
</div>
</div>
<p>This geometric picture connects directly to information refinement: as algebras refine (capturing more information), their <span class="math inline">\(L^2\)</span> spaces expand (allowing more functions to be represented). The filtration <span class="math display">\[
\mathcal{F}_1 \subset \mathcal{F}_2 \subset \mathcal{F}_3
\]</span> from our coin-flip example corresponds to a nested sequence of subspaces <span class="math display">\[
L^2(\mathcal{F}_1) \subset L^2(\mathcal{F}_2) \subset L^2(\mathcal{F}_3),
\]</span> where each larger subspace can represent more refined information about the outcomes.</p>
</section>
<section id="conditional-expectations-as-projections" class="level2">
<h2 class="anchored" data-anchor-id="conditional-expectations-as-projections">Conditional expectations as projections</h2>
</section>
<section id="coin-flips-revisited" class="level2">
<h2 class="anchored" data-anchor-id="coin-flips-revisited">Coin flips revisited</h2>
</section>
<section id="brief-note-on-sufficient-statistics" class="level2">
<h2 class="anchored" data-anchor-id="brief-note-on-sufficient-statistics">Brief note on sufficient statistics</h2>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
</section>
<section id="bibliography" class="level2">




</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">Bibliography</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Kallenberg2021" class="csl-entry" role="listitem">
Kallenberg, O. 2021. <em>Foundations of Modern Probability</em>. Third. Vol. 99. Probability Theory and Stochastic Modelling. Springer.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/johnmyers-phd\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>